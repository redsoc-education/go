
В процессе работы программа как привило занимается обработкой данных в том или ином виде. Для того чтобы работать с данными, данные нужно где-то хранить. Существует две основные концепции для хранения данных. Прежде чем разбирать их, рассмотрим как данные в целом хранятся.

Мы уже знаем, что информация хранится в виде набора нулей и единиц (двоичный код). Так например, число 1 (единица) с типом int8 будет представлено в виде идущих подряд семи нулей и одной единицы - 00000001, а то же самое число но с типом int64 будет выглядеть как 63 нуля и 1 единица.

Логичнее (1) было бы хранить единицу в виде одной 1, двойку и тройку в виде 10 и 11 и тд?
Не совсем. Переменные имеют тип, а это значит, что при определении той или иной переменной мы выделяем под неё участок памяти, который может принимать определённый вид.

Представим, что мы создали структуру с целочисленным полем и присвоили значение 1
```go
type ov struct {
	a int64
}

func buk() {
	var v v
	v.a = 1
}
```
Руководствуясь логикой (1) мы выделим под поле "a" 1 бит. Но теперь мы записываем в него двойку
```go
type ov struct {
	a int64
}

func buk() {
	var v ov 
	v.a = 1
	v.a = 2
}
```
Значит мы должны определить новый участок памяти, так как сейчас оно занимает 1 байт. После алокации, мы запишем "10" и поле "a" теперь будет иметь размер 2 байта.

В действительности, при создании поля с определённым типом под него выделяется фиксированное количество байт и при изменении значения меняется набор байт в конкретном участке памяти.

У такого подхода есть ещё одна (можно сказать основная) причина - выравнивание. Для нас, как для разработчиков очевидно, что переменная, которая имеет значение 1 и в двоичной системе будет выглядеть как 1, а 2 в десятичной примет вид 10. Действительно, зачем, если мы решаем подобную задачу на бумаге, писать 63 незначащих нуля? Можно же сэкономить место на бумаге и ручку!

Компьютер, в то же время, не знает ни о каких ручках и бумагах, ровно так же он и не понимает значения выражения "незначащие нули". Для процессора все нули - что-то значат (отсутствие сигнала).

Рассматривая задачу на бумаге, нам легко увидеть, единичку сверху, двойку пониже, слева плюсик и сложить. Для процессора память выглядит иначе - в виде (относительно) бесконечного потока из нулей и единиц. Поэтому такое ограничение в 8 байт на переменную выступает в роли разделителя. Читая последовательно кусок памяти, процессор понимает что с 0 по 8 байт лежит переменная "a", с 8 по 18 "b", а с 18 по 24 "c"
```go
type ov struct {
	a int64
	b float64
	c bool
}

func buk() {
	var v ov
	v.a = 1
	v.b = 2.0
	v.c = true
}
```
С полями "a" и "b" понятно, они занимают добрых 8 байт так как могут принять множество значений,  но тип bool может принять только 2 значения, почему под него нужно выделять 8 байт?

>Определить размер становится возможным с помощью следующей конструкции

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println(unsafe.Sizeof(ov{}))
}

type ov struct {
	a int64
	b float64
	c bool
}

func buk() {
	var v ov
	v.a = 1
	v.b = 2.0
	v.c = true
}
```

```shell
| 24
```

Связано это с тем, что процессор (в частности 64битный) за раз читает кусок памяти размером 8 байт - это называется машинное слово.  Мы не можем сказать процессору читать меньше или больше, это приводило бы больше к проблемам и путанице в управлении памяти, чем к решению проблем с потреблением памяти.

> Однако, если мы после переменной "c" расположим ещё 7 переменных  с типом bool, размер структуры не вырастет!

Ещё один трюк с структурами - пустая структура.
```go
type empty struct{}
```

Если мы попытаемся вызывать функцию определения размера относительно объекта с типом `empty` мы увидим, что он весит 0. Связано это с тем, что пустая структура единожды инициализируется при старте и везде переиспользуется. Использовать пустую структуру удобно для реализации хеш-сета, где нам необходимо хранить только ключи, без значения 

> Помним, что если делать хеш сет на связке ключ+bool, каждая запись будет занимать 1 байт как минимум 

Управление памятью регулируется двумя основными концепциями. Упорядоченное управление - стэк и беспорядочное - куча.