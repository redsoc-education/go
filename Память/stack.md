Стэк - как и в случае с структурой данных "стэк" представляет собой набор байт, идущих по порядку.
На практике, стэк - это участок памяти доступный текущему контексту исполнения.

# Пример
Рассмотрим пример.
```go
package main

import (
	"fmt"
	"runtime/debug"
)

func main() {
	first()
}

func first() {
	second()
}

func second() {
	third()
}

func third() {
	stackTrace := debug.Stack()
	fmt.Printf("%s\n", stackTrace)
}
```

Из основной функции (main) происходит последовательный запуск функций "first", "second" и "third". В последней мы просим напечатать стэк вызова.
В результате получаем
```shell
| goroutine 1 [running]:
| runtime/debug.Stack()
| 	/usr/local/go-faketime/src/runtime/debug/stack.go:26 +0x5e
| main.third()
| 	/tmp/sandbox922714870/prog.go:23 +0x13
| main.second(...)
| 	/tmp/sandbox922714870/prog.go:19
| main.first(...)
| 	/tmp/sandbox922714870/prog.go:15
| main.main()
| 	/tmp/sandbox922714870/prog.go:11 +0x11
```
Можем видеть, как программа дошла до места вызова (читать снизу вверх). Начала свой путь в main.main - первое слово - название пакета, второе - название функции/метода

Точно так же, на каждом этапе вызова, для следующей функции выделяется кусочек памяти, который кладётся поверх текущего 

Добавим переменных на каждом этапе и рассмотрим потребление памяти

```go
package main

import (
	"fmt"
	"runtime/debug"
)

func main() {
	a := first()
	_ = a
}

func first() int8 {
	b := second()
	b2 := int8(6)
	b = b + third()
	retun b + b2
}

func second() int8 {
	d = int8(6) + third()
	return d
}

func third() int8 {
	stackTrace := debug.Stack()
	fmt.Printf("%s\n", stackTrace)
	
	g := int8(4)
	return g
}
```

На каждом этапе мы инициализируем переменную типа int8 (для простоты, чтобы не писать 64 нуля возьмём именно такой размер), а также читаем результат другой функции в том или ином виде.

## Вызов main
До вызова функции происходит только определение переменной "a", в которую в будущем должно будет вернутся значение с типом int (это язык видит на этапе компиляции и нет необходимости явно указывать, что "а" имеет тип int)

На данном этапе (очень грубо) стэк выглядит следующим образом. Мы предопределили место под переменную, но в ней пока пусто
```
main.main: | 00000000 |
```

## Вызов first
Перед тем как выполнение зайдёт в функцию "first" для неё выделится память, которой хватит для четырёх переменных: 
1. переменная b
2. переменная b2
3. результат выполнения "third"
4. результат сложения тоже должен где-то лежать, даже если мы явно не указываем имя переменной
Стэк до выполнения функции будет выглядеть следующим образом
```
main.first | 00000000 | // b          
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат 
-----------------------
main.main: | 00000000 |
```


## Вызов second
Аналогично при входе в функцию second будет выделен кусок памяти следующим образом

```
main.second | 00000000 | // результат выполнения third         
            | 00000000 | // d
-----------------------
main.first | 00000000 | // b          
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

## Вызов third
Войдём наконец в последнюю функцию и увеличим стэк ещё на 1 байт

```
main.third | 00000000 | // g         
-----------------------
main.second | 00000000 | // результат выполнения third
            | 00000000 | // d
-----------------------
main.first | 00000000 | // b          
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

Каждый кусок памяти отделённый горизонтальной пунктирной чертой представляет собой отдельный кусок памяти, доступный только функции для которой он выделяется. Из стэка одной функции мы (пока что) не можем управлять и видеть переменные в других функциях. Ни в вышестоящих ни в нижележащих.

Кусок памяти конкретной функции называется **кадром** памяти
## Выполнение third
Функция достаточно простая, поэтому рассмотрим только относящийся к ней кадр, который принимает следующий вид

```
main.third | 00000100 | // g = 4  
```

Эта же переменная будет использоваться для возвращения из функции.
При выходе её значение будет копироваться в вызывающую функцию, а значит общий вид стэка примет следующее состояние.

```
main.second | 00000100 | // результат выполнения third
            | 00000000 | // d
-----------------------
main.first | 00000000 | // b          
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

Как можно увидеть, после выполнения, кадр, относившийся к функции third был стёрт - это значит, что если нам понадобится память которая ранее была занята этой функцией мы можем её переиспользовать 

> на самом деле память не перетирается нулями и не удаляется, а просто помечается как доступная для использования

В этом и заключается главная прелесть такого подхода - быстрое создание (выделение) кадров и быстрая очистка при выходе
## Выполнение second
После того как third будет исполнен, функция second запишет в переменную "d" сумму  предопределённого значения (константы) 6 и результата выполнения, а после вернёт результат в вызывающую функцию (опять произойдёт копирование из кадра main.second в кадр main.first)

До возвращения из функции "second"
```
main.second | 00000100 | // результат выполнения third = 4
            | 00001010 | // d = 10
-----------------------
main.first | 00000000 | // b          
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

После возвращения в "first"
```
main.first | 00001010 | // b = 10      
           | 00000000 | // b2
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

## Выполнение first
После того как "second" вернул значение, функция кладёт в "b2" шестёрку  - 6 и стэк принимает следующий вид

```
main.first | 00001010 | // b = 10      
           | 00000110 | // b2 = 6
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

Далее по уже знакомому для нас сценарию создаётся новый кадр в рамках которого будет выполнятся функция third, результат которой запишется в кадр "first" на третье место (помечено комментарием)

```
main.third | 00000000 | // g    
-----------------------
main.first | 00001010 | // b = 10      
           | 00000110 | // b2 = 6
           | 00000000 | // результат выполнения third
		   | 00000000 | // результат
-----------------------
main.main: | 00000000 |
```

> Не будем останавливаться на деталях работы "third", их мы рассмотрели выше. Стоит отметить, однако, что в данном случае для выполнения main.third использовалась физически та же самая память, что и для main.second.

Перед выходом из функции "first" стэк выглядит следующим образом

```
main.first | 00001010 | // b = 10      
           | 00000110 | // b2 = 6
           | 00000100 | // результат выполнения third = 4
		   | 00010100 | // результат = 20
-----------------------
main.main: | 00000000 |
```

## Возвращение домой (в main.main)
После того как "first" выполнится и исполнение вернётся в "main" стэк примет вид и программа завершится

```
main.main: | 00010100 | 
```
